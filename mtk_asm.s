/* ===================================================================
 * mtk_asm.s
 * マルチタスクカーネル アセンブリ言語パート
 * =================================================================== */

.include "equdefs.inc"

    .section .text
    .even

/* ===================================================================
 * first_task
 * 最初のタスクを起動する関数
 *
 * 概要:
 * curr_task で指定されたタスクのTCBから初期SSPを復元し、
 * スタック上に構築されたコンテキスト(USP, レジスタ, PC, SR)を
 * ハードウェアに戻して RTE することで、ユーザタスクへ移行する。
 * この関数は begin_sch() から呼ばれるが、RTEするので戻ってこない。
 * =================================================================== */
    .global first_task
    .extern task_tab
    .extern curr_task
    
first_task:
    /* ---------------------------------------------------------------
     * 1. TCBのアドレス計算
     * A0 = &task_tab[curr_task]
     * --------------------------------------------------------------- */
    lea.l    task_tab, %a0
    move.l   curr_task, %d0
    mulu.w   #20, %d0        /* sizeof(TCB)=20バイト */
    adda.l   %d0, %a0

    /* ---------------------------------------------------------------
     * 2. SSPの復帰 (最重要処理)
     * TCBの stack_ptr (オフセット4) に保存されている
     * 「スタックの底(初期構築済み)」のアドレスを実際のSPに設定する
     * --------------------------------------------------------------- */
    move.l   4(%a0), %sp

    /* --- これでスタックポインタが「タスク用システムスタック」に切り替わった --- */

    /* ---------------------------------------------------------------
     * 3. USPの復帰
     * init_stack でスタックの一番上に積んだ値は初期USPである
     * --------------------------------------------------------------- */
    move.l   (%sp)+, %a0     /* スタックからUSPの値を取り出す */
    move.l   %a0, %usp       /* CPUのUSPレジスタに設定 */

    /* ---------------------------------------------------------------
     * 4. 汎用レジスタの復帰
     * init_stack で積んだダミーレジスタ(0)を復帰させる
     * --------------------------------------------------------------- */
    movem.l  (%sp)+, %d0-%d7/%a0-%a6

    /* ---------------------------------------------------------------
     * 5. タスク開始
     * スタックに残っている SR と PC (タスク開始アドレス) を戻してジャンプ
     * --------------------------------------------------------------- */
    rte


/* ===================================================================
 * pv_handler
 * TRAP #1 割り込み処理ルーチン (システムコールハンドラ)
 *
 * 概要:
 * P/Vシステムコールの分岐処理を行う。
 * 引数 %d0=0 -> P命令, %d0=1 -> V命令
 * =================================================================== */
    .global pv_handler
    .extern p_body
    .extern v_body
    
pv_handler:
    /* ---------------------------------------------------------------
     * 1. レジスタ退避
     * 実行中のタスクの全レジスタをスタックに保存する
     * --------------------------------------------------------------- */
    movem.l %d0-%d7/%a0-%a6, -(%SP)
    
    /* ---------------------------------------------------------------
     * 2. 割り込み禁止設定
     * 現在のSRを保存し、走行レベルを7(割り込み禁止)にする
     * これにより、カーネル処理中のタイマ割り込み等を防ぐ
     * --------------------------------------------------------------- */
    move.w  %SR, -(%SP)
    move.w  #0x2700, %SR

    /* ---------------------------------------------------------------
     * 3. システムコールの分岐判定
     * %d0 の値によって p_body または v_body を呼び分ける
     * --------------------------------------------------------------- */
    cmp.i   #0, %d0
    beq     to_p_body    /* %d0=0なら to_p_bodyへ */
    cmp.i   #1, %d0
    beq     to_v_body    /* %d0=1なら to_v_bodyへ */

    /* 想定外のシステムコール番号の場合は何もせず終了 */
    bra     pv_handler_finish

to_p_body:
    move.l  %d1, -(%SP)   /* 引数(sem_id)をスタックに積む */
    jsr     p_body        /* C言語の p_body を呼ぶ */
    move.l  (%SP)+, %d1   /* 積んだ引数を破棄してSPを戻す */
    bra     pv_handler_finish

to_v_body:
    move.l  %d1, -(%SP)   /* 引数(sem_id)をスタックに積む */
    jsr     v_body        /* C言語の v_body を呼ぶ */
    move.l  (%SP)+, %d1   /* 積んだ引数を破棄してSPを戻す */
    bra     pv_handler_finish
    
pv_handler_finish:
    /* ---------------------------------------------------------------
     * 4. 状態復帰とリターン
     * --------------------------------------------------------------- */
    move.w  (%SP)+, %SR               /* SRの値をスタックから復帰(割り込み許可状態に戻る) */
    movem.l (%SP)+, %d0-%d7/%a0-%a6   /* 最初に退避したレジスタを復帰 */
    rte


/* ===================================================================
 * P
 * Pシステムコールの入り口 (C言語から呼ばれる)
 * 概要:
 * 引数 sem_id を取得し、TRAP #1 (機能番号0) を発行する
 * =================================================================== */
    .global P
P:
    /* ---------------------------------------------------------------
     * 1. レジスタ退避
     * Cコンパイラの保存則に従い、破壊してはいけないレジスタを保存
     * --------------------------------------------------------------- */
    movem.l %d0-%d1/%a0, -(%SP)
    
    /* ---------------------------------------------------------------
     * 2. システムコール準備
     * 機能番号 0 (P命令) を %d0 にセット
     * --------------------------------------------------------------- */
    move.l  #0, %d0
    
    /* ---------------------------------------------------------------
     * 3. 引数(sem_id) の取得
     * 現在のSPを基準にオフセット計算して取得する
     * オフセット = 退避したレジスタ(3*4=12byte) + 戻り番地(4byte) = 16byte
     * --------------------------------------------------------------- */
    move.l  %SP, %a0
    adda.l  #16, %a0
    move.l  (%a0), %d1    /* %d1 に sem_id をセット */
    
    /* ---------------------------------------------------------------
     * 4. システムコール実行
     * --------------------------------------------------------------- */
    TRAP    #1

    /* ---------------------------------------------------------------
     * 5. 復帰
     * --------------------------------------------------------------- */
    movem.l (%SP)+, %d0-%d1/%a0
    rts


/* ===================================================================
 * V
 * Vシステムコールの入り口 (C言語から呼ばれる)
 * 概要:
 * 引数 sem_id を取得し、TRAP #1 (機能番号1) を発行する
 * =================================================================== */
    .global V
V:
    /* ---------------------------------------------------------------
     * 1. レジスタ退避
     * --------------------------------------------------------------- */
    movem.l %d0-%d1/%a0, -(%sp)
    
    /* ---------------------------------------------------------------
     * 2. システムコール準備
     * 機能番号 1 (V命令) を %d0 にセット
     * --------------------------------------------------------------- */
    move.l  #1, %d0
    
    /* ---------------------------------------------------------------
     * 3. 引数(sem_id) の取得
     * オフセット = 16byte (Pと同様)
     * --------------------------------------------------------------- */
    move.l  %SP, %a0
    adda.l  #16, %a0
    move.l  (%a0), %d1    /* %d1 に sem_id をセット */
    
    /* ---------------------------------------------------------------
     * 4. システムコール実行
     * --------------------------------------------------------------- */
    TRAP    #1
    
    /* ---------------------------------------------------------------
     * 5. 復帰
     * --------------------------------------------------------------- */
    movem.l (%SP)+, %d0-%d1/%a0
    rts


/* ===================================================================
 * swtch
 * タスクの切り替え (コンテキストスイッチ)
 *
 * 概要:
 * 現在のタスク(curr_task)のコンテキストを保存し、
 * 次のタスク(next_task)のコンテキストを復元して切り替える。
 * C言語関数として呼ばれるが、戻るときはRTEを使用する。
 * =================================================================== */
    .global swtch
    .extern curr_task
    .extern next_task
    .extern task_tab

swtch:
    /* ---------------------------------------------------------------
     * 1. 現在のタスクのコンテキスト保存
     * --------------------------------------------------------------- */
    /* C言語関数として呼ばれるが、復帰時はRTEを使いたいのでSRを積む */
    move.w   %sr, -(%sp)
    
    /* 汎用レジスタ全退避 */
    movem.l  %d0-%d7/%a0-%a6, -(%sp)
    
    /* USPの保存 (特権モードなのでmove.l %usp, ...を使用) */
    move.l   %usp, %a0
    move.l   %a0, -(%sp)

    /* SSPの保存 (TCBのstack_ptrへ) */
    /* A0 = &task_tab[curr_task] */
    lea.l    task_tab, %a0
    move.l   curr_task, %d0
    mulu.w   #20, %d0
    adda.l   %d0, %a0
    
    /* 現在のSP(SSP)を TCB->stack_ptr (offset 4) に書き込む */
    move.l   %sp, 4(%a0)


    /* ---------------------------------------------------------------
     * 2. 次のタスクへの切り替え
     * curr_task 変数を next_task の値で更新する
     * --------------------------------------------------------------- */
    move.l   next_task, %d0
    move.l   %d0, curr_task


    /* ---------------------------------------------------------------
     * 3. 新しいタスクのコンテキスト復帰
     * --------------------------------------------------------------- */
    /* A0 = &task_tab[curr_task] (新しいタスク) */
    lea.l    task_tab, %a0
    /* %d0にはすでにnext_taskが入っている */
    mulu.w   #20, %d0
    adda.l   %d0, %a0

    /* TCB->stack_ptr から SP(SSP) を復元 */
    move.l   4(%a0), %sp

    /* --- スタック切り替わり完了 --- */

    /* USP復帰 */
    move.l   (%sp)+, %a0
    move.l   %a0, %usp

    /* 汎用レジスタ復帰 */
    movem.l  (%sp)+, %d0-%d7/%a0-%a6

    /* ---------------------------------------------------------------
     * 4. 復帰
     * スタック上のSRとPC(戻り番地)を使ってRTEする
     * --------------------------------------------------------------- */
    rte


/* ===================================================================
 * hard_clock
 * タイマ割り込みハンドラ (アセンブリ側エントリ)
 *
 * 概要:
 * タイマ割り込み発生時にCPUから自動的に呼び出される。
 * 割り込み前の処理を破壊しないよう全レジスタを退避し、
 * C言語で書かれた本体処理 (hard_clock_body) を呼び出す。
 * その後、タスク切り替え (swtch) を行い、復帰する。
 * =================================================================== */
    .global hard_clock
    .extern hard_clock_body

hard_clock:
    /* ---------------------------------------------------------------
     * 1. SR退避&割り込み禁止設定
     * 元のSR状態を保存するため、スタックに積み、割り込み禁止に設定する。
     * --------------------------------------------------------------- */
    move.w  %SR, -(%SP)
    move.w  #0x2700, %SR
    
    /* ---------------------------------------------------------------
     * 2. 全レジスタ退避
     * 割り込み元の処理状態を保存するため、全てのレジスタをスタックに積む
     * --------------------------------------------------------------- */
    movem.l %d0-%d7/%a0-%a6, -(%SP)

    /* ---------------------------------------------------------------
     * 3. 割り込み処理本体の呼び出し
     * Readyキューへの追加やスケジューリングを行う
     * --------------------------------------------------------------- */
    jsr     hard_clock_body
    
    /* ---------------------------------------------------------------
     * 4. タスク切り替え
     * sched() で決定された next_task へ切り替える
     * --------------------------------------------------------------- */
    jsr     swtch

    /* ---------------------------------------------------------------
     * 5. レジスタ&SR復帰
     * (切り替え後のタスクの) レジスタ値をスタックから戻す
     * もとのSRの状態に戻す(割り込み許可)
     * --------------------------------------------------------------- */
    movem.l (%SP)+, %d0-%d7/%a0-%a6
    move.w  (%SP)+, %SR
    
    /* 割り込み復帰 */
    rts


/* ===================================================================
 * init_timer
 * タイマ初期化ルーチン
 *
 * 概要:
 * モニタのシステムコールを利用して、タイマ割り込みを設定する。
 * =================================================================== */
    .global init_timer

init_timer:
    /* 使用するレジスタを退避 */
    movem.l %d0-%d2, -(%SP)

    /* ---------------------------------------------------------------
     * システムコールによる SET_TIMER の起動
     * %D0: 機能番号 (SET_TIMER)
     * %D1: 割り込み周期 (10000 * 0.1ms = 1秒)
     * %D2: 割り込みハンドラのアドレス (hard_clock)
     * --------------------------------------------------------------- */
    move.l #SYSCALL_NUM_SET_TIMER, %D0
    move.w #10000, %D1
    move.l #hard_clock, %D2
    trap #0

    /* レジスタ復帰 */
    movem.l (%SP)+, %d0-%d2
    rts

/* ===================================================================
 * skipmt
 * 強制タスク切り替え (skip multi-task)
 *
 * 概要:
 * タイマ関連のシステムコール機能番号5を利用して、
 * 擬似的にタイマ割り込み処理(hard_clock相当)を呼び出し、
 * 自発的にCPU時間を手放す。
 * =================================================================== */
    .global skipmt

skipmt:
    movem.l %d0, -(%SP)

    /* システムコール番号 5 を指定して trap #0 を実行 */
    move.l #SYSCALL_NUM_SET_SKIPMT, %d0
    trap #0

    movem.l (%SP)+, %d0
    rts
