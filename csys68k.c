/* ===================================================================
 * csys68k.c
 * C言語標準ライブラリ(libc)とハードウェアの結合部分
 *
 * 概要:
 * read/write/fcntl などのシステムコールレベルの関数を実装し、
 * stdio (printf/scanf) が動作するようにする。
 * ファイルディスクリプタ(FD)によってポートを振り分ける。
 * =================================================================== */

#include <stdarg.h>

/* 外部関数の宣言 (アセンブリ言語で実装) */
extern int inbyte(int ch);
extern void outbyte(int ch, unsigned char c);
extern void skipmt(void); /* マルチタスク用: 強制タスク切り替え */

/* -------------------------------------------------------------------
 * ファイルディスクリプタ(FD)とポートの対応定義
 * ------------------------------------------------------------------- */
#define FD_PORT0 0  /* 標準入出力等は Port0 (UART1) へ */
#define FD_PORT1 4  /* FD 4 は Port1 (UART2) へ */

/* fcntl用定数 (必要な場合) */
#ifndef F_GETFL
#define F_GETFL 3
#endif
#ifndef O_RDWR
#define O_RDWR  2
#endif


/* ===================================================================
 * read(fd, buf, nbytes)
 * データの読み込み
 *
 * 概要:
 * FDに応じたポートから1バイトずつ読み込み、バッファに格納する。
 * データがない場合は skipmt() を呼び出して他タスクにCPUを譲る。
 * (ブロッキングI/Oの振る舞いを、協調的マルチタスクで実現)
 * =================================================================== */
int read(int fd, char *buf, int nbytes)
{
    char c;
    int  i;
    int  ch;
    int  val;

    /* ---------------------------------------------------------------
     * 1. ポート(チャンネル)の決定
     * --------------------------------------------------------------- */
    if (fd == FD_PORT1) {
        ch = 1; /* Port1 (UART2) */
    } else {
        ch = 0; /* Port0 (UART1) - デフォルト */
    }

    /* ---------------------------------------------------------------
     * 2. 指定バイト数分の読み込みループ
     * --------------------------------------------------------------- */
    for (i = 0; i < nbytes; i++) {
        
        /* --- データ受信待ちループ (ポーリング + skipmt) --- */
        while (1) {
            /* モニタのノンブロッキング入力関数を呼ぶ */
            val = inbyte(ch);
            
            if (val != -1) {
                /* データ受信成功 */
                c = (char)val;
                break; 
            }
            
            /* データがまだ来ていない場合、
             * 無駄にループせず、他のタスクに実行権を譲る */
            skipmt();
        }

        /* --- エコーバックと特殊文字処理 --- */
        if (c == '\r' || c == '\n'){ 
            /* 改行コードの統一出力 (\r\n) */
            outbyte(ch, '\r');
            outbyte(ch, '\n');
            *(buf + i) = '\n'; /* バッファには \n を格納 */
        } 
        else if (c == '\x7f' || c == '\x08'){ 
            /* Backspace (DEL/BS) 対応 */
            if (i > 0){
                /* 画面上の文字を消去するシーケンス */
                outbyte(ch, '\x8'); /* カーソル戻す */
                outbyte(ch, ' ');   /* 空白で上書き */
                outbyte(ch, '\x8'); /* 再度カーソル戻す */
                i--; /* バッファインデックスを戻す */
            }
            i--; /* 今回のループ分をキャンセル */
            continue;
        } 
        else {
            /* 通常文字: エコーバックしてバッファに格納 */
            outbyte(ch, c);
            *(buf + i) = c;
        }

        /* 改行が来たら、指定バイト数未満でもそこまででリターンする (行入力対応) */
        if (*(buf + i) == '\n'){
            return (i + 1);
        }
    }
    
    return (i);
}


/* ===================================================================
 * write(fd, buf, nbytes)
 * データの書き込み
 * =================================================================== */
int write (int fd, char *buf, int nbytes)
{
    int i, j;
    int ch;

    /* ---------------------------------------------------------------
     * 1. ポート(チャンネル)の決定
     * --------------------------------------------------------------- */
    if (fd == FD_PORT1) {
        ch = 1;
    } else {
        ch = 0;
    }

    /* ---------------------------------------------------------------
     * 2. 出力ループ
     * --------------------------------------------------------------- */
    for (i = 0; i < nbytes; i++) {
        /* 改行コードの変換 (\n -> \r\n は必要に応じて調整) */
        if (*(buf + i) == '\n') {
            outbyte(ch, '\r');
        }
        
        /* 1文字出力 */
        outbyte(ch, *(buf + i));
        
        /* 簡易ウェイト (連続出力時のバッファ溢れ防止等のため) */
        for (j = 0; j < 300; j++);
    }
    
    return (nbytes);
}


/* ===================================================================
 * fcntl(fd, cmd, ...)
 * ファイル制御 (fdopen の内部で使用される)
 *
 * 概要:
 * 簡易実装。F_GETFL に対して常に O_RDWR (読み書き可) を返す。
 * これにより fdopen が成功するようになる。
 * =================================================================== */
int fcntl(int fd, int cmd, ...)
{
    if (cmd == F_GETFL) {
        return O_RDWR;
    }
    return 0;
}