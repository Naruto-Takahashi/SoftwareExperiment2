/* ===================================================================
 * mtk_c.c
 * マルチタスクカーネル C言語パート
 * =================================================================== */
#include <stdio.h>
#include "mtk_c.h"

/* -------------------------------------------------------------------
 * 外部関数の宣言 (アセンブリ言語で定義されている関数)
 * ------------------------------------------------------------------- */
extern void pv_handler();
extern void hard_clock();
extern void swtch();
extern void first_task();
extern void init_timer();

/* ===================================================================
 * 大域変数の実体定義
 * (mtk_c.h で extern 宣言されている変数の実体)
 * =================================================================== */

/* -------------------------------------------------------------------
 * カーネル管理データ
 * ------------------------------------------------------------------- */
/* セマフォ配列 */
SEMAPHORE_TYPE semaphore[NUMSEMAPHORE];

/* TCB配列 (ID=1から使うため +1 する) */
TCB_TYPE task_tab[NUMTASK + 1];

/* スタック配列 (ID=1のタスクが stacks[0] を使う) */
STACK_TYPE stacks[NUMTASK];

/* -------------------------------------------------------------------
 * システム制御用変数
 * ------------------------------------------------------------------- */
TASK_ID_TYPE curr_task;  /* 現在実行中のタスクID */
TASK_ID_TYPE new_task;   /* 新規作成中のタスクID */
TASK_ID_TYPE next_task;  /* 次に実行するタスクID */
TASK_ID_TYPE ready;      /* 実行待ちタスクキューの先頭ID */

volatile unsigned long tick = 0; /* タイマティックカウンタ */

/* -------------------------------------------------------------------
 * 2ポート入出力用ファイルポインタ
 * ------------------------------------------------------------------- */
FILE *com0in;   /* Port0 (UART1) 入力 */
FILE *com0out;  /* Port0 (UART1) 出力 */
FILE *com1in;   /* Port1 (UART2) 入力 */
FILE *com1out;  /* Port1 (UART2) 出力 */


/* ===================================================================
 * init_kernel
 * カーネルの初期化処理
 *
 * 概要:
 * TCB、Readyキュー、セマフォ、割り込みベクタの初期化を行う。
 * システム起動時に最初に一度だけ呼ばれる。
 * =================================================================== */
void init_kernel(void)
{
    int i;

    /* ---------------------------------------------------------------
     * 1. TCB配列の初期化
     * 全てのタスクを未定義(UNDEFINED)状態にし、リンクをクリアする
     * --------------------------------------------------------------- */
    for (i = 1; i <= NUMTASK; i++) {
        task_tab[i].status = UNDEFINED;
        task_tab[i].next = NULLTASKID;
    }

    /* ---------------------------------------------------------------
     * 2. Readyキューの初期化
     * 最初は誰も待機していないのでNULLTASKIDとする
     * --------------------------------------------------------------- */
    ready = NULLTASKID;

    /* ---------------------------------------------------------------
     * 3. セマフォの初期化
     * カウンタを1(利用可能)、待ち行列を空に設定する
     * --------------------------------------------------------------- */
    for (i = 0; i < NUMSEMAPHORE; i++) {
        semaphore[i].count = 1;
        semaphore[i].nst = 0;
        semaphore[i].task_list = NULLTASKID;
    }

    /* ---------------------------------------------------------------
     * 4. 割り込みベクタの設定
     * TRAP #1 (システムコール) ベクタに pv_handler を登録する
     * ベクタ番号 33 -> アドレス 33*4 = 132 (0x84)
     * --------------------------------------------------------------- */
    *(void (**)())0x84 = pv_handler;
}

/* ===================================================================
 * init_stack
 * タスク用スタックの初期化
 *
 * 引数:
 * id: 初期化対象のタスクID
 * 戻り値:
 * 初期化後のスーパバイザスタックポインタ(SSP)の値
 * =================================================================== */
void *init_stack(TASK_ID_TYPE id)
{
    /* ---------------------------------------------------------------
     * 1. 作業用ポインタの準備
     * スーパバイザスタックの「底（上限アドレス）」を取得する
     * stacks配列は0始まり、idは1始まりなので [id-1] を使用
     * --------------------------------------------------------------- */
    char *sp_base = stacks[id - 1].sstack + STKSIZE;
    
    /* アドレス操作用ポインタ (4バイト単位で動かすため long* にキャスト) */
    unsigned long *sp_l = (unsigned long *)sp_base;
    unsigned short *sp_w;
    int i;

    /* 以降スタックにデータを積んでいく (アドレスは減っていく) */

    /* ---------------------------------------------------------------
     * 2. Initial PC (戻り先アドレス) [4バイト]
     * タスク関数の先頭アドレスをセットする
     * --------------------------------------------------------------- */
    sp_l--;                 /* ポインタを4バイト戻す */
    *sp_l = (unsigned long)task_tab[id].task_addr;

    /* ---------------------------------------------------------------
     * 3. Initial SR (ステータスレジスタ) [2バイト]
     * 4バイトポインタを2バイトポインタにキャストして操作
     * --------------------------------------------------------------- */
    sp_w = (unsigned short *)sp_l;
    sp_w--;                 /* ポインタを2バイト戻す  */
    *sp_w = 0x0000;         /* ユーザモード(S=0), 割り込み許可(Level 0) */

    /* ---------------------------------------------------------------
     * 4. レジスタ退避領域 (D0-D7, A0-A6) [15本 * 4バイト = 60バイト]
     * movem.l 命令で退避される順番に合わせて領域を確保
     * 初期値は0で埋める
     * --------------------------------------------------------------- */
    sp_l = (unsigned long *)sp_w;   /* long型ポインタに戻す */
    
    for (i = 0; i < 15; i++) {
        sp_l--;             /* 4バイト戻す */
        *sp_l = 0;          /* ダミーデータ(0)で埋める */
    }

    /* ---------------------------------------------------------------
     * 5. Initial USP (ユーザスタックポインタ) [4バイト]
     * ユーザスタックの「底」のアドレスを計算して格納する
     * 安全のため少しマージン(-16)を取る
     * --------------------------------------------------------------- */
    sp_l--;
    *sp_l = (unsigned long)(stacks[id - 1].ustack + STKSIZE - 16);

    /* 作成したスタックの先頭アドレス(SSP)を返す */
    return (void *)sp_l;
}

/* ===================================================================
 * set_task
 * ユーザタスクの登録
 *
 * 引数:
 * func: タスクとして実行する関数のポインタ
 * =================================================================== */
void set_task(void (*func)())
{
    int i;
    TASK_ID_TYPE id = NULLTASKID;

    /* ---------------------------------------------------------------
     * 1. タスクIDの決定
     * task_tab[]の中から、空いている(UNDEFINED)場所を探す
     * IDは 1 から始まるので、i=1 からループする
     * --------------------------------------------------------------- */
    for (i = 1; i <= NUMTASK; i++) {
        if (task_tab[i].status == UNDEFINED) {
            id = i;
            break;  /* 空きが見つかったのでループを抜ける */
        }
    }

    /* 空きスロットが見つからなかった場合は登録できないので終了 */
    if (id == NULLTASKID) {
        return;
    }

    /* ---------------------------------------------------------------
     * 2. グローバル変数 new_task の更新
     * --------------------------------------------------------------- */
    new_task = id;

    /* ---------------------------------------------------------------
     * 3. TCB (Task Control Block) の設定
     * 実行アドレスと、初期状態(READY)を設定
     * --------------------------------------------------------------- */
    task_tab[id].task_addr = func;
    task_tab[id].status = READY;

    /* ---------------------------------------------------------------
     * 4. スタックの初期化
     * init_stack を呼び出してスタックフレームを構築し、SSPを保存
     * --------------------------------------------------------------- */
    task_tab[id].stack_ptr = init_stack(id);

    /* ---------------------------------------------------------------
     * 5. Readyキューへの登録
     * --------------------------------------------------------------- */
    addq(&ready, id);
}

/* ===================================================================
 * begin_sch
 * マルチタスク処理の開始
 *
 * 概要:
 * 最初のタスクを取り出し、タイマを起動し、タスクへ制御を移す。
 * =================================================================== */
void begin_sch()
{
    /* Readyキューから最初のタスクを取り出し、curr_taskにする */
    curr_task = removeq(&ready);
    
    /* タイマ割り込みを開始 */
    init_timer();
    
    /* 最初のタスクを起動 (ここから戻ってくることはない) */
    first_task();
}

/* ===================================================================
 * addq
 * キューへのタスク追加
 *
 * 引数:
 * queue: 対象キューの先頭IDへのポインタ
 * new_task: 追加するタスクID
 * 概要:
 * 指定されたキューの末尾にタスクを追加する。
 * =================================================================== */
void addq(TASK_ID_TYPE *queue, TASK_ID_TYPE new_task)
{
    if ((*queue) == NULLTASKID) {
        /* キューが空の場合は先頭にセット */
        (*queue) = new_task;
    } else {
        /* キューの末尾を探して追加 */
        TASK_ID_TYPE prev = (*queue);
        TASK_ID_TYPE curr = task_tab[prev].next;
        
        while (curr != NULLTASKID) {
            prev = curr;
            curr = task_tab[curr].next;
        }
        task_tab[prev].next = new_task;
    }
}

/* ===================================================================
 * removeq
 * キューからのタスク取り出し
 *
 * 引数:
 * queue: 対象キューの先頭IDへのポインタ
 * 戻り値:
 * 取り出されたタスクID (キューが空なら NULLTASKID)
 * 概要:
 * 指定されたキューの先頭からタスクを取り除き、そのIDを返す。
 * =================================================================== */
TASK_ID_TYPE removeq(TASK_ID_TYPE *queue)
{
    if ((*queue) == NULLTASKID) {
        return NULLTASKID;
    } else {
        TASK_ID_TYPE task = (*queue);
        (*queue) = task_tab[(*queue)].next;
        
        /* 取り出したタスクのリンク情報はクリアしておく */
        task_tab[task].next = NULLTASKID;
        return task;
    }
}

/* ===================================================================
 * sched
 * スケジューラ
 *
 * 概要:
 * Readyキューの先頭から次に実行するタスクを取り出し、next_taskにセットする。
 * 実行可能なタスクがない場合は無限ループで待機する。
 * =================================================================== */
void sched()
{
    next_task = removeq(&ready);
    
    if (next_task == NULLTASKID) {
        /* 実行可能タスクがない場合のアイドルループ */
        while (1) {
            /* 割り込み待ちなどを行うのが一般的だが、ここでは単純ループ */
        }
    }
}

/* ===================================================================
 * sleep
 * タスクの休眠
 *
 * 引数:
 * ch: 待ち行列(セマフォ)のID
 * 概要:
 * 現在のタスク(curr_task)をWAITING状態にし、指定されたセマフォのキューへ移動。
 * その後、次のタスクへ切り替える(swtch)。
 * =================================================================== */
void sleep(int ch)
{   
    /* curr_taskはキューの末尾になるので、次はNULLにしておく */
    task_tab[curr_task].next = NULLTASKID;
    
    /* タスクの状態を「待ち」に変更 */
    task_tab[curr_task].status = WAITING;
    
    /* セマフォの待ち行列に追加 */
    addq(&semaphore[ch].task_list, curr_task);
    
    /* 次のタスクを決定し、切り替える */
    sched();
    swtch();
}

/* ===================================================================
 * wakeup
 * タスクの起床
 *
 * 引数:
 * ch: 待ち行列(セマフォ)のID
 * 概要:
 * 指定されたセマフォのキュー先頭からタスクを取り出し、Readyキューへ移す。
 * =================================================================== */
void wakeup(int ch)
{
    TASK_ID_TYPE woken_task = removeq(&semaphore[ch].task_list);
    
    if (woken_task == NULLTASKID) {
        return; /* 待っているタスクがいなければ何もしない */
    }
    
    /* 取り出したタスクの状態を実行可能(READY)に変更 */
    task_tab[woken_task].status = READY;
    
    /* Readyキューに追加 */
    addq(&ready, woken_task);        
}

/* ===================================================================
 * p_body
 * P操作 (Wait) の本体
 *
 * 引数:
 * sem_id: 操作対象のセマフォID
 * 概要:
 * セマフォカウントを減算し、負になった場合はタスクをスリープさせる。
 * =================================================================== */
void p_body(int sem_id)
{
    semaphore[sem_id].count--;
    
    if (semaphore[sem_id].count < 0) {
        sleep(sem_id);
    }
}

/* ===================================================================
 * v_body
 * V操作 (Signal) の本体
 *
 * 引数:
 * sem_id: 操作対象のセマフォID
 * 概要:
 * セマフォカウントを加算し、待機中のタスクがいれば1つ起床させる。
 * =================================================================== */
void v_body(int sem_id)
{
    semaphore[sem_id].count++;
    
    if (semaphore[sem_id].count <= 0) {
        wakeup(sem_id);
    }
}

/* ===================================================================
 * hard_clock_body
 * タイマ割り込み処理のC言語パート
 *
 * 概要:
 * ティックカウントを更新し、現在のタスクをReadyキューに戻して、
 * ラウンドロビンスケジューリングのために次のタスクを決定する。
 * =================================================================== */
void hard_clock_body(void)
{
    tick++;
    
    /* 現在のタスクをReadyキューの末尾に回す(ラウンドロビン) */
    addq(&ready, curr_task);
    
    /* 次に実行するタスクを決定 */
    sched();    
}